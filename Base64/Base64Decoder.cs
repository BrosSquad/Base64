using System;
using System.Runtime.CompilerServices;

namespace Base64
{
    public class Base64Decoder : Base64, IDecoder
    {
        private static byte[] _decodeTable =
        {
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 62, 128, 128, 128, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 128, 128, 128, 0, 128, 128, 128, 0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 128, 128, 128, 128,
            128, 128, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
            50, 51, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128,
        };


        private static byte[] _decodeTableUrlSafe =
        {
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 62, 128, 128, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 128, 128, 128, 0, 128, 128, 128, 0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 128, 128, 128, 128,
            63, 128, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
            51, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 128, 128, 128, 128, 128,
        };

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Memory<byte> Decode(ReadOnlySpan<byte> base64, Variant variant)
        {
            byte[] data = new byte[EncodedLengthToBytes(base64)];
            Decode(data, base64, variant);
            return data;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe void Decode(Span<byte> dst, ReadOnlySpan<byte> base64, Variant variant)
        {
            int i, count;
            bool isUrlSafe = ((int) variant & (int) Mask.UrlSafe) > 0;
            byte* block = stackalloc byte[4];

            fixed (byte* destBytes = dst)
            fixed (byte* table = isUrlSafe ? _decodeTableUrlSafe : _decodeTable)
            {
                byte* destPointer = destBytes;

                for (i = 0, count = 0; i < base64.Length; i++)
                {
                    byte tmp = table[base64[i]];
                    if (tmp == 0x80)
                        continue;
                    block[count] = tmp;
                    count++;
                    if (count == 4)
                    {
                        *destPointer++ = (byte) ((block[0] << 2) | (block[1] >> 4));
                        *destPointer++ = (byte) ((block[1] << 4) | (block[2] >> 2));
                        *destPointer++ = (byte) ((block[2] << 6) | block[3]);
                        count = 0;
                    }
                }

                if (((int) variant & (int) Mask.NoPadding) != 0)
                {
                    *destPointer++ = (byte) ((block[0] << 2) | (block[1] >> 4));
                    *destPointer++ = (byte) ((block[1] << 4) | (block[2] >> 2));
                    *destPointer = (byte) ((block[2] << 6) | block[3]);
                }
            }

            //
            // for (i = 0; i < len; i++)
            // {
            //     tmp = dtable[src[i]];
            //     if (tmp == 0x80)
            //         continue;
            //     [count] =
            //     src[i];
            //     block[count] = tmp;
            //     count++;
            //     if (count == 4)
            //     {
            //         *pos++ = (block[0] << 2) | (block[1] >> 4);
            //         *pos++ = (block[1] << 4) | (block[2] >> 2);
            //         *pos++ = (block[2] << 6) | block[3];
            //         count = 0;
            //     }
            // }

            // if (pos > out)
            // {
            //     if (in[
            //     2] == '=')
            //     pos -= 2;
            //     else if (in[
            //     3] == '=')
            //     pos--;
            // }
        }
    }
}